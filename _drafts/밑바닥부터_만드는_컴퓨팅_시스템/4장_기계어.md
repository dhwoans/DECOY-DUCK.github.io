## 기계어

>기계어 프로그램을 실행시킬 수 있는 컴퓨터를 만들기 위해서 우선적으로 기계어에 대해 먼저 알아본다.

### 이 장에서 구현해 볼 것들

- 곱셈프로그래밍
- I/O 조작 프로그래밍

> 기계어란?   
>    
> 프로세스와 레지스터들을 이용해 메모리를 조작할수 있도록 미리 정해둔 규칙

## 기본 지식

기계어는 대상 플렛폼에 직접적으로 명령을 실행하고 하드웨어를 제어하는 것을 목표로한다.

기계어가 어떤하드웨어 플랫폼을 사용할 수 있도록 설계된것이라 한다면 반대로 하드웨어 플랫폼은 그 기계어로 작성된 명령어를 불러오고 해석하고 실행할 수 있도록 설계된 것이라고 말할수 있다.

때문에 컴퓨터 아키텍처를 완전히 이해라기 위해서는 저수준 프로그래밍을 이해할 필요가 있다

### 어셈블리

'R1를 R2+R3으로 설정하라'라는 명령어를 컴퓨터에서 실행시키기 위해서는 0101010100001과 같은 식으로
바꿔야 한다. 

하지만 이런 2진 코드는 인간이 쓰고 이해하기에 무리가 있기 때문에 한 단계 추상화하여 기호를 사용해 명령어를 표현할 수 있을 것이다.

그러면 이런 명령어를 텍스처 처리 프로그램을 이용해 각 표현들을 분석하여 2진 표현으로 바꾼 후 전체 코드를 2진 기계어로 번역할 수 있다. 

이런 기호 표기법을 `어셈블리 assembly`라고 부르며, 어셈블리를 2진 코드로 번역하는 프로그램을 `어셈블러 assembler`라고 한다.

어셈블리는 컴퓨터마다 다르지만 일반적은 명령의 구성은 다음과 같다

- 산술 및 논리 연산
- 메모리 접근
- 제어 흐름

### 구현을 해보자

핵언어라는 저수준 언어를 이용해서 곱셉프로그램과 I/O 조작 프로그램을 만든다. 때문에 핵언어에 대해 제대로 이해해야 과제 구현이 가능하다.

핵언어는 A-명령어라고 부르는 주소 명령어와 C-명령어라고 부르는 계산 명령어로 나눠져 있다. 

A-명령어 : 이 명령어는 A 레지스터에 특정값을 저장하도록 한다. 세가지 용도로 쓸 수 있다

1. 상수 입력
2. C-명령어에서 해당 주소에 있는 값을 참조 할 수 있도록 A레지스터에 데이터 주소를 미리 입력
3. A레지스터에 점프할 주소를 미리 입력 

C-명령어 : 핵 플랫폼에서 거의 모든 일을 수행하는 명령어.

### `작업 순서`

코드 작성 -> 어셈블러 2진 코드 명령어 파일 생성 -> cpu 예뮬레이터 실행

2단계로 작업이 진행 되는데 문서 편집기에서 만든 .asm 파일을 어셈블러에 실행시키면 .hack 파일이 만들어 진다. 만약 문제가 있다면 오류가 발생하게 된다. 


### `곱셈 프로그램`

R0과 R1을 곱한 값을 R2에 저장하면 된다. 곱하기는 여러번 더한 것과 같다. 때문에 R0과 R1을 곱한다는 말은 R0을 R1번 반복해서 더한다는 말과 같다. 

이것을 코드로 구현하려면 R2에 R0값을 누적해서 저장할때마다 R1값을 하나씩 빼고 R1값이 0이 되면 프로그램을 종료 시키면 된다.
```
//결과값 저장할 R2 초기값 0설정
    @R2
    M=0

(LOOP)
    @R0
    D=M
    //0이면 탈출
    @END
    D;JEQ

    @R0
    M=D-1
    @R1
    D=M
    @R2
    M=M+D
    @LOOP
    0;JMP

(END)
    //종료
    @END
    0;JMP
```

매크로 명령을 사용하면 코드를 많이 줄일수 있다

```
    M[R2]=0

(LOOP)
    D=M[R0]
    @END
    D;JEQ
    M=D[R0]-1
    D=M[R1]
    M=M+D[R2]
    @LOOP
    0;JMP

(END)
    @16
    0;JMP
```


### `I/O 조작 프로그램`
```
@color         
	M=0            

(loop)
    @SCREEN    // RAM address 16384
    D=A

    @pixels 
    M=D       // pixel address (starting point: 16384, max: 16384+8192=24576)

    @KBD      // D = ascii code of a keyboard input
    D=M

    @black
    D;JGT     // if(keyboard > 0) goto black

    @color
    M=0       // otherwise white
    
    @color_screen
    0;JMP     // jump to subroutine that actually changes the color of screen

    (black)
        @color
        M=-1  // set to black

    (color_screen)
        @color
        D=M
        @pixels
        A=M
        M=D   // M[pixels] = @color

        @pixels
        M=M+1
        D=M

        @24576 // loop until end of pixels
        D=D-A
        @color_screen
        D;JLT

@loop
0;JMP         // infinite loop

```




