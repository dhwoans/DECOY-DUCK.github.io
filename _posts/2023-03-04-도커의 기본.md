---
layout: post
title: Docker dive
subtitle: 고래등에 올라타기
banner:
  image: https://user-images.githubusercontent.com/57062736/139102730-d6f51d53-ffb3-44bb-be5e-2bdf48d91295.png
  opacity: 0.618
  background: "#000"
  heading_style: "font-size: 4.25em; font-weight: bold; "
author: 오재문
categories: [DevOps]
tags: [Docker,도커교과서]
comments: true

---

##  Hollo Docker


> "애플리케이션을 필요한 모든 의존 모듈과 함께 패키징하고 어디서든 동일한 방식으로 실행할 수 있게 하자" 도커는 바로 이러한 개념에서 출발한 매우 멋진 기술이다. 도커가 실현한 이 세계에서 노트북, 데이터센터,클라우드 어디서든 애플리케이션을 똑같이 실행할 수 있다.

새로운 스택을 접했을 때 처음부터 하나씩 배워나가는 것도 좋지만 복잡한 이론 앞에 열정이 식는 경우가 있습니다. 

복잡한 이론은 잠시 뒤로 하고 이 멋진 기술이 우리에게 무엇을 가져다줬는지에 집중해 보겠습니다. 아무쪼록 도커라는 놀라운 기술을 잘 이해할 수 있었으면 좋겠습니다.

---

## 빌드 공유 실행

![image](https://user-images.githubusercontent.com/51963264/224186916-b1472474-39b4-4f3d-ab50-4aa69e821c2a.png)


도커의 핵심은 `빌드`,`공유`,`실행`으로 정리할 수 있습니다. 먼저 애플리케이션을 컨테이너에서 실행할 수 있도록 패키징하고 다른 사람이 패키지를 사용할 수 있도록 공유한 다음, 이 패키지를 내려받은 사람이 컨테이너를 통해 애플리케이션을 실행합니다. 도커는 그것을 가능하게 하는 컴포넌트들로 구성되어 있습니다. 

도커는 `컨테이너`라는 경량 단위로 앱을 실행하는 기능을 제공하는 플랫폼입니다. 때문에 도커를 이용해 애플리케이션을 실행시키려면 컨테이너라는 기술을 사용하게 됩니다. 

## 컨테이너

`컨테이너`는 이름에서 알 수 있듯이 물건을 담는 상자와 다를 것 없습니다. 컨테이너 안에는 애플리케이션과 애플리케이션을 실행시킬 환경으로 구성되어 있습니다. 

도커는 컨테이너의 호스트명,IP주소,파일 시스템 등과 같은 가상 리소스들을  관리합니다. 컨테이너들은 서로 독립된 환경을 갖지만 호스트의 CPU,메모리 및 운영체제를 공유하게 됩니다. 경우에 따라서 도커는 호스트의 네트워크 계층에서 트래픽을 가로채 필요한 것을 컨테이너에 전달하기도 합니다.

독립된 환경을 가진다는 것은 꽤 중요한 문제 입니다. 한 호스트 내에  다수의 애플리케이션을 실행시키는 것은 많은 제약이 따르기 때문입니다. 서로 호환되지 않는 라이브러리를 사용하는 경우나 한 애플리케이션이 리소스를 과도하게 점유할 수도 있습니다. 이런 문제는 호스트 추가 및 관리 등의 비용 문제로 이어질 수 있습니다. 컨테이너 등장 이전 시대에서는 가상머신을 이용해 환경을 격리시킴으로써 이 문제를 해결했습니다. 

가상머신과 컨테이너의 유일한 차이는 호스트의 운영체제를 공유입니다. 가상 머신은 각각 별도의 운영체제를 필요로하고 컨테이너는 호스트의 운영체제를 공유하기 때문에 그 만큼 필요한 리소스가 줄어들게 됩니다. 때문에 컨테이너는 가상머신과 비교했을 때 애플리케이선을 경량으로 실행할 수 있습니다.

---

## 이미지

도커에서 `이미지`는 컨테이너와 마찬가지로 도커를 지탱하고 있는 `핵심 중 하나`입니다. 모든 컨테이너는 이미지를 바탕으로 실행되며, 이 때 이미지는 컨테이너가 실행되는 파일 시스템입니다.

도커 이미지를 가져오는 명령어를 보내면 도커는 가장 먼저 이미지를 찾기 위해 도커 허브에 접근하게 됩니다. 이때 도커 허브와 같이 이미지를 제공하는 저장소를 `레지스트리 registry`라고 부릅니다.

### 이미지 레이어


![image](https://user-images.githubusercontent.com/51963264/191139653-942f2e38-3a2d-4d76-9674-6b51cd0490ae.png)

이미지를 내려받는 과정을 보면 여러 건을 파일을 내려 받는 모습이 보이는데 이들 각 파일을 `이미지 레이어`라고 부릅니다. 이 과정을 통해 도커 이미지는 물리적으로 여러개의 작은 파일로 구성된다는 것을 알 수 있다. 도커는 이러한 작은 파일들을 조립해 컨테이너의 내부 시스템을 만듭니다.

```bash
#명령어를 통해 알 수도 있습니다.
docker image history [OPTIONS] IMAGE
```

여기서 중요한 점은 만약 이미지를 가져올 때 중복된 이미지 레이어가 있다면 해당 이미지 레이어를 공유한다는 것입니다. 이러한 특성으로 인해 저장 공간을 획기적으로 줄일 수 있는데 만약 그 이미지 레이어가 수정된다면 레이어를 공유하는 다른 이미지에 영향을 주기 때문에 레이어를 읽기 전용으로 만들어 두어 수정을 방지합니다.

>이미지에서 run 명령어를 통해 컨테이너가 만들어지는 순간 컨테이너 레이어가 최상위에 추가되어 동작하는데 사용자가 입력하는 모든 행동은 container layer에서 이루어지며, 환경을 구성하는 이미지 레이어를 변경하는 것은 불가능하다. 

## Dockerfile

특별한 경우를 제외하면 대부분의 도커 이미지는 `Dockerfile`을 통해 만듭니다. Dockerfile은 인스트럭션으로 구성되는데 도커는 인스트럭션을 이미지 레이어와 일대일 대응되게 도커 이미지를 만들어냅니다.

Dockerfile 스크립트를 잘 작성하는 것만으로도 사간, 저장 공간, 네트워크 대역폭을 절약할 수 있습니다. `Dockerfile 스크립트 최적화`라고 불리는데 
알아보겠습니다.

도커는 한번 사용한 이미지 레이어는 캐시 메모리에 저장합니다. 그리고 해시값을 이용해 이미지 레이어를 식별합니다. 만약 Dockerfile 스크립트에서 전에 사용한 레이어가 있다면 캐시된 레이어를 재사용하게 되고 없다면 캐시 미스가 발생해 해당 캐시는 무효가 되고 인스트럭션이 실행하게 됩니다. 그 다음 인스트럭션은 수정된 것인지 확인하지 않고 바로 실행 됩니다. 때문에 Dockerfile 스크립트를 작성할때 잘 수정되지 않는 인스트럭션일 수록 상위 쪽으로 배치해야 합니다. 그렇게 해야 캐시에 저장된 이미지 레이어를 많이 재사용 할 수 있기 때문입니다. 

---

## 애플리케이션 소스 코드에서 이미지까지

>현대 IT기술을 주도하는 요소 중 하나는 `일관성`이다. 개발 팀은 모든 프로젝트에서 같은 도구, 같은 프로세스, 동일한 런타임을 사용하길 원한다. 도커를 사용하면 이러한 요구를 만족시킬 수 있다.

도커가 갖춰진 환경이라면 어떤 환경에서든 애플리케이션을 실행할 수 있을 뿐아니라 빌드할 수 있습니다. 아시다시피 대부분의 프로그래밍 언어는 빌드에 다양한 도구들 사용하게 됩니다.그리고 이 도구들을 관리한다는 것은 큰 규모일 때 시간적으로나 비용적으로 힘든 일일 수 있습니다. `멀티 스테이지 빌드`는 이 부분을 해결해줄 수 있습니다.

### 멀티 스테이지 빌드

앞서 배운 최적화와 마찬가지로 이미지를 작게 만드려는 여러가지 시도가 있었습니다. 이미지가 작으면 작을수록 배포시간은 짧아지기 때문입니다. 이러한 시도 끝에 **하나의 도커파일**에 여러 빌드 단계를 나눠 빌드가 순차적으로 이뤄지는 멀티스테이지 빌드 패턴이 탄생하게 되었습니다.


![image](https://user-images.githubusercontent.com/51963264/224485135-b4735bfa-5d1f-4c3e-aed7-7b85cfaa4fae.png)

>빌드,테스트,배포와 같은 중요 관심 사에 따라 필요한 필요한 최소한의 레이어만 사용하도록 단계를 나누는 방법입니다.


각 빌드단계는 서로 격리되어 있습니다. 빌드 단계 별로 기반 이미지도 다를 수 있습니다. 그리고 어느 단계라도 실패하면 전체 빌드가 실패하게 됩니다. 이 패턴을 사용하면 어떤 복잡한 애플리케이션이라도 하나의 도커파일로 빌드 할 수 있습니다. 

이런 패턴을 사용해서 컨테이너로 애플리케이션을 빌드하면 어떤 이점이 있는지는 다음과 같이 정리할 수 있습니다.

- 빌드 과정을 표준화할 수 있습니다

로컬 컴퓨터에 어떤 도구가 설치되어 있는지와는 상관없는 모든 빌드 과정은 컨테이너 안에서만 이뤄집니다. 또한 컨테이너 안의 모든 도구들은 모두 정확한 버전을 가지게 됩니다. 이는 새로 팀에 합류하는 신입 개발자가 즉시 개발 환경을 갖출 수 있고 다른 개발자 간의 도구 버전 차이로 인한 빌드 실패 가능성을 크게 줄일 수 있습니다.

- 최종 이미지를 작게 유지할 수 있습니다

멀티 스테이지를 사용하면 최종산출물인 이미지에 불필요한 도구는 빼버릴 수 있습니다.예를 들어 빌드 스테이지에서 빌드에 필요한 종속성은 실제로 동작하는 러닝 이미지에서는 필요하지 않습니다. 때문에 빌드 스테이지에서 만들어낸 바이너리만 받아서 사용하는 방식으로 이미지 크기를 줄여 용량 뿐만 아니라 배포 시간을 줄일 수 있습니다. 거기다 애플리케이션의 의존 모듈자체 또한 줄어 취약점을 이용한 외부 공격 가능성도 차단할 수 있습니다.

---

## 도커 레지스트리

이제까지 도커의 핵심 워크플로인 빌드와 실행에 대해 배웠다면 마지막으로 공유에 대해 배워보겠습니다. 도커 이미지를 가져오는 명령어를 보내면 도커는 가장 먼저 이미지를 찾기 위해 도커 허브에 접근하게 됩니다. 이때 도커 허브와 같이 이미지를 제공하는 저장소를 `레지스트리 registry`라고 부른다고 언급한 적 있습니다. 

도커 플랫폼은 도커 허브를 기본 레지스트리로 설정하고 있습니다. 때문에 도커 이미지를 내려 받을 때 생략되는 경우가 있는데 이미지의 전체이름은 다음과 같이 구성됩니다.  
```
{레지스트리 도메인}/{작성자명}/{리포지토리명}:{이미지 태그}
```

레지스트리 도메인은 따로 지정하지 않으면 기본 설정값을 사용하게 됩니다. 레지스트리 도메인의 기본값은 `docker.io`입니다. 규모가 있는 기업의 경우 레지스트리를 따로 두는 경우가 있을 것입니다. 이런 경우 레지스트리 도메인을 기재하면 도커는 도커 허브 대신 그 경로로 이미지를 탐색하게 됩니다. 

이미지 작성자가 신경써야할 부분은 `{작성자명}/{리포지토리명}`일 것입니다. 공개된 이미지라면 누구나 이 포맷으로 이미지를 내려받을 수 있으므로 다른 사람이 이미지를 올바르게 사용하게 하기 위해서 상세한 정보를 이미지 이름에 포함시킬 것을 고려해야 합니다. 

이미지 태그 또한 따로 지정하지 않으면 `latest`값이 지정됩니다. 태그는 버전을 구별하기 위해 쓰여집니다. 때문에 직접 이미지를 만들게 된다면 오해를 불러일으키지 않기 위해 명시적으로 태그를 부여하는 것이 좋습니다. 태그를 표기하는 것은 버전을 표기하는 방식과 같습니다.

---

## 데이터와 도커 볼륨,바인드 마운트

대부분의 경우 새 이미지를 빌드하고 오래된 컨테이너를 삭제한 다음 이미지에서 실행한 컨테이너를 대체하는 식으로 새로운 버전으로 업그레이드합니다.여기서 중요한 점은 컨테이너가 삭제될 경우 컨테이너에 쓰여진 데이터도 함께 사라진다는 점입니다. 만약 데이터베이스의 경우 그런 식으로 업데이트를 하면 데이터까지 삭제되어 큰 문제가 발생할 수 있습니다. 때문에 컨테이너가 대체되어도 데이터를 남길 장치가 필요합니다. 즉, 컨테이너의 생명 주기와 관계없이 데이터를 영속적으로 저장할 수 있도록 해야하는데 도커에는 이를 위한 두가지 요소가 있습니다. `도커 볼륨`과 `마운트`입니다.

### 도커 볼륨 

>볼륨의 장점은 컨테이너와 스토리지의 생애주기를 분리하면서도 도커를 사용하는 방식 그대로 스토리지를 다룰 수 있는 점이다. 

볼륨은 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만 컨테이너와 연결할 수 있습니다. 볼륨을 컨테이너와 연결하는 방법은 두가지 입니다. 첫번째는 수동입력을 통해 볼륨을 만들고 컨테이너와 연결하는 방법이 있고 두번째는 VOLUME이라는 인스트럭션을 Dockerfile 스크립트에 사용하는 것입니다. 

유의할 점은 단일 컨테이너뿐만 아니라 여러 개의 컨테이너가 하나의 볼륨에 접근할 수 있다는 것입니다. 즉, 볼륨에 데이터를 저장해두고, 여러 컨테이너에 연결만 해주면 해당 데이터는 모든 컨테이너에서 접근할 수 있게 됩니다. 이러한 접근이 허용된다면 애플리케이션이 비정상적으로 작동할 수 있습니다. 때문에 데이터 공유 목적으로써의 사용보다는 **상태보존 목적으로 사용하길 권장드립니다.**

### 💡 --volume 플래그 와 VOLUME 인스트럭션

>Dockerfile 스크립트의 VOLUME 인스트럭션과 docker container 몀령의 --volume 플래그는 별개의 기능이다.VOLUME 인스트럭션을 사용해 빌드된 이미지로 docker container run 명령에서 볼륨을 지정하지 않으면 새로운 볼륨을 함께 생성한다.
>
>반면 --volume 플래그는 이미지에 볼륨이 정의되어 있든 말든 지정된 볼륨을 컨테이너에 마운트한다. **이미지에 볼륨이 정의되어 있더라도 무시되므로 새로운 볼륨이 생성되지 않는다.

### bind mount

볼륨이 도커 플랫폼내에서의 수단이라면 마운트는 호스트와 직접 연결할 수 있는 수단입니다. 바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉토리를 컨테이너 파일 시스템의 디렉토리로 만듭니다.  호스트 파일 시스템에 의존해서 사용되기 때문에 볼륨에 비해 상대적으로 기능이 제한적일 수 있습니다. 

가령 마운트하고자 하는 컨테이너의 디렉터리 안에 파일이 존재한 상태로 마운트를 하게 된다면 기존에 존재한 내용은 전부 대체되게 됩니다.그래서 이미지에 있던 원래 파일은 사용할 수 없게 됩니다.

---

## 마치며

Docker는 단일 컨테이너 관리에 적합하도록 만들어져 있습니다. 하지만 모든 일을 단일 컴포넌트가 맡아 수행하는 애플리케이션은 그리 많지 않습니다. 애플리케이션은 대개 여러 요소로 분할되어 구성되기 마련입니다. 때문에 여러 컨테이너를 실행하고 관리하는 법은 도커가 아닌 조금 다른 기술을 통해 해결해야 합니다.